#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@title: Andrew class
@description: methods and classes for the liquid handling robot Andrew (Andrew Alliance, model 1000G)
@author: chrisarcadia 
@created: 2018/03/29
"""
from lxml import etree
import time
from datetime import datetime
from copy import deepcopy
import os
import random

#import io
#import chemcpupy as ccpu

# note that by default:
#  - volumes are specified in nanoliters (nL)
#  - colors are specified in the decimal form of hexadecimal web colors

# class for creating valid Andrew Lab Protocol (ANP) files 
class Protocol(object):
    
    def __init__(self):   
        # intialize structure  
        self.name = "New Protocol"
        self.author = "Author Name"
        self.author_email  = "author@email.com"
        self.version = "1.5.2"        
        self.encoding = "UTF-8"     
        self.pipetting_policy = "rows"    # policy options: {rows, rows_s, columns, columns_s}
        self.stock_solutions = [];        # list of StockSolutions
        self.library_of_consumables = []; # list of LibraryConsumbales
        self.consumables = [];            # list of Consumables
        self.actions = [];                # list of Actions
    
    def makeTree(self): # consolidate main XML branches
        root = etree.Element("protocol", attrib={'version':self.version});  
        data = etree.Element("data");
        public = Protocol.generatePublic(self); 
        private = Protocol.generatePrivate(self);
        library = Protocol.generateLibrary(self);
        stock_solutions = Protocol.generateStockSolutions(self); 
        consumables = Protocol.generateConsumables(self);
        pipette_set = Protocol.generatePipetteSet(self);
        actions = Protocol.generateActions(self);        
        root.append(public)
        data.append(private);
        data.append(library);
        data.append(stock_solutions);
        data.append(consumables);
        data.append(pipette_set);
        data.append(actions);
        root.append(data);
        return root
        
    def __str__(self):
        return etree.tostring(Protocol.makeTree(self), 
                              pretty_print=True, 
                              encoding="unicode")
                
    def write(self,filename):
        xml = etree.tostring(Protocol.makeTree(self), 
                              pretty_print=True, 
                              xml_declaration=False, 
                              encoding=self.encoding);        
        file = open(filename,'wb'); # open file in write-byte (wb) mode 
        declaration = '<?xml version=\"1.0\" encoding=\"' + self.encoding + '\"?>\n';
        file.write(declaration.encode(self.encoding))
        file.write(xml);          
        file.close();
                        
    def generatePublic(self):
        root = etree.Element("public");        
        currentdate = datetime.now();
        GMT_offset = time.strftime("+%H%M", time.gmtime(time.localtime().tm_gmtoff));
        date = currentdate.strftime("%a %b %m %H:%M:%S")+" GMT"+GMT_offset+" "+currentdate.strftime("%Y");
        modified = etree.Element("last_modification_date"); 
        modified.text = etree.CDATA(date);
        rev = etree.Element("revision"); 
        rev.text = etree.CDATA('1'); # assumes this is revision #1 of your protocol
        name = etree.Element("name"); 
        name.text = etree.CDATA(self.name);
        created = etree.Element("creation_date"); 
        created.text = etree.CDATA(date);
        iden = etree.Element("id"); 
        desc = etree.Element("description"); 
        icon = etree.Element("icon", attrib={'default':'true'}); 
        #iconimage = ''; # an image preview (will be autogenerated in AndrewLab) of the workbench for this protocol (encoded as base64)
        #icon.text = etree.CDATA(iconimage);
        root.append(iden);
        root.append(desc);
        root.append(name);        
        root.append(rev);
        root.append(created);
        root.append(modified);        
        root.append(icon);
        return root
        
    def generatePrivate(self):
        root = etree.Element("private");  
        author = etree.Element("author"); 
        author.text = etree.CDATA(self.author); 
        email = etree.Element("author_email"); 
        email.text = etree.CDATA(self.author_email); 
        policy = etree.Element("pipetting_policy"); 
        policy.text = etree.CDATA(self.pipetting_policy);         
        root.append(author);
        root.append(email);
        root.append(policy);
        return root
        
    def generateLibrary(self):
        root = etree.Element("library");  
        if self.library_of_consumables is not None:
            for consumable in self.library_of_consumables:  
                xml = LibraryConsumable.toXML(consumable);
                if xml is not None:
                    root.append(xml);                
        return root 
    
    def generateStockSolutions(self):
        root = etree.Element("stock_solutions");
        if self.stock_solutions is not None:
            for solution in self.stock_solutions:  
                xml = StockSolution.toXML(solution);
                if xml is not None:
                    root.append(xml);                
        return root
    
    def generatePipetteSet(self):
        #root = etree.Element("set");
        parser = etree.XMLParser(strip_cdata=False);
        classfilepath = os.path.dirname(os.path.realpath(__file__));
        doc = etree.parse(classfilepath + "/resource/pipette_set.xml",parser);
        root = doc.getroot();
        return root
    
    def generateConsumables(self):
        root = etree.Element("consumables");  
        if self.consumables is not None:        
            for consumable in self.consumables:   
                xml = Consumable.toXML(consumable);
                if xml is not None:
                    root.append(xml);
        return root     

    def generateActions(self):
        root = etree.Element("actions");  
        if self.actions is not None:        
            for action in self.actions:   
                xml = Action.toXML(action);
                if xml is not None:
                    root.append(xml);
        return root 
 
# class for a library consumable (a type of consumable)
class LibraryConsumable(object):
    
    def __init__(self,**kwargs):
        params_required = (  'shortname',
                             'type',
                             'preparation',
                             'version',
                             'id',
                             'name',
                             'display_name',
                             'description',
                             'category',
                             'volume_dead', # [nL]
                             'volume_max',  # [nL]
                             'size_columns',
                             'size_rows',
                             )                    
        params = kwargs            
        if not set(params_required).issubset(params):
            raise Exception('not given all required parameters')
        else:
            self.__dict__.update(params)
    
    def toXML(self):
        xml = etree.Element("consumable", attrib={'shortname':str(self.shortname), 
                                                  'type':str(self.type).lower(),
                                                  'preparation':str(self.preparation).lower(),
                                                  'version':str(self.version),
                                                  'id':str(self.id)});   
        name = etree.Element("name"); 
        name.text = etree.CDATA(str(self.name)); 
        display_name = etree.Element("display_name"); 
        display_name.text = etree.CDATA(str(self.display_name)); 
        description = etree.Element("description"); 
        description.text = etree.CDATA(str(self.description)); 
        category = etree.Element("category"); 
        category.text = etree.CDATA(str(self.category));     
        volumes = etree.Element("volumes", attrib={'dead':str(self.volume_dead),'max':str(self.volume_max)});         
        xml.append(name);
        xml.append(display_name);
        xml.append(description);
        xml.append(category);
        xml.append(volumes);
        if self.size_columns*self.size_rows>1:
            size = etree.Element("size", attrib={'columns':str(self.size_columns),'rows':str(self.size_rows)});                  
            xml.append(size);        
        return xml    
    
    def __str__(self):
        return etree.tostring(LibraryConsumable.toXML(self), 
                              pretty_print=True, 
                              encoding="unicode")
        
    def fromStandard(type)   :
        consumable = None;
        if type=='microplate384':
            consumable = LibraryConsumable(  shortname='MTP384',
                                             type = 'microplate384',
                                             preparation = 'group',
                                             version = 2,
                                             id = 'microplate384',
                                             name = '384-well plate',
                                             display_name = 'MTP384',
                                             description = 'Generic microplate with 384 wells. This consumable describes typical square-shaped wells of capacity below 120 uL - with exclusion of 384-wells PCR microplates',
                                             category = 'Microplates',
                                             volume_dead = 10000, # [nL]
                                             volume_max = 120000,  # [nL]
                                             size_columns = 24,
                                             size_rows = 16);
        if type=='microplate96':
            consumable = LibraryConsumable(  shortname='MTP96',
                                             type = 'microplate96',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'microplate96',
                                             name = '96-well plate',
                                             display_name = 'MTP96',
                                             description = 'Generic 96-wells microplate. It can have a flat, round or conical bottom - but not a PCR microplate. Dead volumes minimization may imply a more precise consumable',
                                             category = 'Microplates',
                                             volume_dead = 100000, # [nL]
                                             volume_max = 400000,  # [nL]
                                             size_columns = 12,
                                             size_rows = 8);  
                                           
        if type=='microplate24':
            consumable = LibraryConsumable(  shortname='MTP24',
                                             type = 'microplate24',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'microplate24',
                                             name = '24-well plate',
                                             display_name = 'MTP24',
                                             description = 'Generic 24 well microplate with flat bottom, mostly for cellular culture use (polystyrene). Also called cell culture plates',
                                             category = 'Microplates',
                                             volume_dead = 450000, # [nL]
                                             volume_max = 3400000,  # [nL]
                                             size_columns = 6,
                                             size_rows = 4);                                               
                                           
        if type=='tube50':
            consumable = LibraryConsumable(  shortname='TB50',
                                             type = 'tube50',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'tube50',
                                             name = '50 mL conical centrifuge tube',
                                             display_name = 'TUBE 50',
                                             description = 'Plastic 50 mL tube, conical bottom (without skirt) and screwable cap. Also called Falcon tube or centrifuge tube',
                                             category = 'Tubes',
                                             volume_dead =  500000, # [nL]
                                             volume_max = 50000000,  # [nL]
                                             size_columns = 1,
                                             size_rows = 1 );   
        if type=='tube15':
            consumable = LibraryConsumable(  shortname='TB15',
                                             type = 'tube15',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'tube15',
                                             name = '15 mL conical centrifuge tube',
                                             display_name = 'TUBE 15',
                                             description = 'Plastic 15 mL tube, conical bottom (without skirt) and screwable cap, mainly used for centrifugation - also called 15 mL Falcon tube.',
                                             category = 'Tubes',
                                             volume_dead =  250000, # [nL]
                                             volume_max = 15000000,  # [nL]
                                             size_columns = 1,
                                             size_rows = 1 ); 
        if type=='tube15rack':
            consumable = LibraryConsumable(  shortname='',
                                             type = 'custom',
                                             preparation = 'individual',
                                             version = 3,
                                             id = '24_tubes_15mL_MULTI',
                                             name = '15 mL conical tube (in 24 position domino)',
                                             display_name = '200.712/3',
                                             description = 'Plastic 15 mL tube, conical bottom (without skirt) and screwable cap, mainly used for centrifugation - also called 15 mL Falcon tube. (Corning #352097). IN A DOMINO WITH 24 POSITIONS',
                                             category = 'Tubes',
                                             volume_dead =  250000, # [nL]
                                             volume_max = 15000000,  # [nL]
                                             size_columns = 6,
                                             size_rows = 4 ); 
                                             
        if type=='tube15coolrack':
            consumable = LibraryConsumable(  shortname='cooledTube50_MULTI',
                                             type = 'custom',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'cooledTube50_MULTI',
                                             name = '50 mL conical centrifuge tube in 8 position domino (Cooled)',
                                             display_name = '200.832/1',
                                             description = 'Plastic 50 mL tube, conical bottom (without skirt) and screwable cap, mainly used for centrifugation - also called 50 mL Falcon tube. (Corning #352097). IN A COOLED CARTRIDGE DOMINO WITH 8 POSITIONS',
                                             category = 'Tubes',
                                             volume_dead =  500000, # [nL]
                                             volume_max = 50000000,  # [nL]
                                             size_columns = 4,
                                             size_rows = 2 );                                              
                                           
        if type=='microtube15':
            consumable = LibraryConsumable(  shortname='MTB15',
                                             type = 'microtube',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'microtube15',
                                             name = '1.5 mL conical µtube',
                                             display_name = 'MICRO 15',
                                             description = 'Microtube with pronounced conical bottom and integrated flip cap (also called Eppendorf tube, FlipTop rube or microcentrifuge tube)',
                                             category = 'Small tubes (<3 mL)',
                                             volume_dead =  50000, # [nL]
                                             volume_max = 1500000,  # [nL]
                                             size_columns = 1,
                                             size_rows = 1 );  

        if type=='microtube20':
            consumable = LibraryConsumable(  shortname='MTB20',
                                             type = 'microtube',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'microtube20',
                                             name = '2.0 mL conical µtube',
                                             display_name = 'MICRO 20',
                                             description = 'Microtube for centrifugation - spherical bottom, cylindrical shape and integrated flip cap (also called Eppendorf tube)',
                                             category = 'Small tubes (<3 mL)',
                                             volume_dead =  70000, # [nL]
                                             volume_max = 2000000,  # [nL]
                                             size_columns = 1,
                                             size_rows = 1 );  
                                           
        if type=='microtube15rack':
            consumable = LibraryConsumable(  shortname='MTB15_RACK',
                                             type = 'custom',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'Microtube15_RACK',
                                             name = '1.5 mL conical µtube',
                                             display_name = 'MICRO 15 RACK',
                                             description = 'Microtube with pronounced conical bottom and integrated flip cap (also called Eppendorf tube, FlipTop rube or microcentrifuge tube)',
                                             category = 'Small tubes (<3 mL)',
                                             volume_dead =  50000, # [nL]
                                             volume_max = 1500000,  # [nL]
                                             size_columns = 5,
                                             size_rows = 3 );  
                                           
        if type=='microtube20rack':
            consumable = LibraryConsumable(  shortname='MTB20_RACK',
                                             type = 'custom',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'Microtube20_RACK',
                                             name = '2.0 mL conical µtube',
                                             display_name = 'MICRO 20 RACK',
                                             description = 'Microtube for centrifugation - spherical bottom, cylindrical shape and integrated flip cap (also called Eppendorf tube)',
                                             category = 'Small tubes (<3 mL)',
                                             volume_dead =  70000, # [nL]
                                             volume_max = 2000000,  # [nL]
                                             size_columns = 5,
                                             size_rows = 3 ); 
        if type=='vial2rack':
            consumable = LibraryConsumable(  shortname='R1_MULTI',
                                             type = 'custom',
                                             preparation = 'individual',
                                             version = 2,
                                             id = '54_vials_2mL_MULTI',
                                             name = '1.5 mL flat bottom vial (in 54 rack)',
                                             display_name = '200.707/1',
                                             description = 'Standard HPLC glass vial with wide opening crimp cap in 54 position rack (Agilent #5022-6502). Dimensions: Ø 12 x 32 mm. (Agilent #5181-3375).',
                                             category = 'Small tubes (<3 mL)',
                                             volume_dead =  100000, # [nL]
                                             volume_max = 1500000,  # [nL]
                                             size_columns = 9,
                                             size_rows = 6 ); 
        if type=='vial20rack':
            consumable = LibraryConsumable(  shortname='V20_MULTI',
                                             type = 'custom',
                                             preparation = 'individual',
                                             version = 3,
                                             id = 'vial20mL_MULTI',
                                             name = '20 mL scintillation glass vial',
                                             display_name = '200.871/1',
                                             description = 'Small Screw-cap glass bottle, capacity: 20mL, dimensions: Ø 28.5 x 60 mm. (Wheaton® # 98656)',
                                             category = 'Tubes',
                                             volume_dead =  600000, # [nL]
                                             volume_max = 20000000,  # [nL]
                                             size_columns = 4,
                                             size_rows = 3 );
        if type=='vial20':
            consumable = LibraryConsumable(  shortname='V20',
                                             type = 'custom',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'vial20mL',
                                             name = '20 mL scintillation glass vial',
                                             display_name = '200.871/1',
                                             description = 'Small Screw-cap glass bottle, capacity: 20mL, dimensions: Ø 28.5 x 60 mm. (Wheaton® # 98656)',
                                             category = 'Tubes',
                                             volume_dead =  600000, # [nL]
                                             volume_max = 20000000,  # [nL]
                                             size_columns = 1,
                                             size_rows = 1 ); 

        if type=='vial20p':
            consumable = LibraryConsumable(  shortname='V7',
                                             type = 'custom',
                                             preparation = 'individual',
                                             version = 2,
                                             id = 'scintVialWwu20mL',
                                             name = '20 mL scintillation plastic vial',
                                             display_name = '200.820/1',
                                             description = 'Small Screw-cap plastic bottle, capacity: 20mL, dimensions: Ø 27 x 60 mm (Wheaton® #986700)',
                                             category = 'Tubes',
                                             volume_dead =  1500000, # [nL]
                                             volume_max = 20000000,  # [nL]
                                             size_columns = 1,
                                             size_rows = 1 ); 



        return consumable
  
    # example: 
    # lc = Andrew.LibraryConsumable(shortname='MTP384',type='microplate384',preparation='group',version=2,id='microplate384',name='384-well plate',display_name='MTP384',description='Generic microplate with 384 wells. This consumable describes typical square-shaped wells of capacity below 120 uL - with exclusion of 384-wells PCR microplates',category='Microplates',volume_dead=10000,volume_max=120000,size_columns=24,size_rows=16)
    # print(str(lc))
    
    

# class for a stock solution
class StockSolution(object):
    
    def __init__(self,**kwargs):
        params_required = [  'name' ];
        params_optional = [  'id',                 
                             'description',
                             'color',                # web color (not in hexadecimal but in decimal form) 
                             'concentration',        # in specified unit
                             'concentration_unit' ]; # valid entries: {'M', 'g/L', 'a.u.'}            
        params_optional_defaults = [ getUniqueID(),  # id                
                                     '',             # description
                                     getNewColor(),  # color
                                     1,              # concentration
                                     'a.u.' ];       # concentration unit                                             
        params = kwargs 
           
        if not set(params_required).issubset(params):
            raise Exception('not given all required parameters')
        else:
            
            # optional parameter defaults
            if not set(params_optional).issubset(params):
                for n in range(0,len(params_optional)):
                    if params_optional[n] not in params:
                        params[params_optional[n]] = params_optional_defaults[n]; 
                        
            # update class parameters            
            self.__dict__.update(params)
            
    
    def toXML(self):
        xml = etree.Element("stock_solution", attrib={'id':str(self.id)});   
        name = etree.Element("name"); 
        name.text = etree.CDATA(str(self.name)); 
        color = etree.Element("color"); 
        color.text = str(self.color); # etree.CDATA(self.color); 
        concentration = etree.Element("concentration", attrib={'unit':str(self.concentration_unit)}); 
        concentration.text = str(self.concentration); # etree.CDATA(self.concentration);         
        xml.append(name);
        description_is_valid = ( (self.description is not None) and (self.description.strip() != '') );
        if description_is_valid : 
            description = etree.Element("description"); 
            description.text = etree.CDATA(str(self.description));
            xml.append(description);                
        xml.append(color);
        xml.append(concentration);
        return xml    
    
    def __str__(self):
        return etree.tostring(StockSolution.toXML(self), 
                              pretty_print=True, 
                              encoding="unicode")
  
    # example: 
    # s = Andrew.StockSolution(id='F618075D-BEE5-7EA2-7583-30243CDA1B49',name='DI Water',description='(PubChem CID:962)',color='13047173',concentration='1',concentration_unit='a.u.')
    # print(str(s))
    
    
# class for a consumable (a parametrized instance of a LibraryConsumable)
class Consumable(object):
    
    def __init__(self,**kwargs):
        params_required = [  'label', 
                             'library_consumable'];
        params_optional = [  'id',                             
                             'gui_position_x',
                             'gui_position_y',                                                      
                             'comment'];
        params_optional_defaults = [ getUniqueID(), # id                       
                                     0,             # gui_position_x
                                     0,             # gui_position_y                                              
                                     ''];           # comment                           
        
        params = kwargs            
        if not set(params_required).issubset(params):
            raise Exception('not given all required parameters')
        else:
            
            # optional parameter defaults
            if not set(params_optional).issubset(params):
                for n in range(0,len(params_optional)):
                    if params_optional[n] not in params:
                        params[params_optional[n]] = params_optional_defaults[n]; 
                        
            # update class parameters                        
            self.__dict__.update(params)
            self.rows = self.library_consumable.size_rows;
            self.columns = self.library_consumable.size_columns;
            self.stock_solutions = [[None for c in range(self.columns)] for r in range(self.rows)]; # stock_solutions[row][column]
            self.volumes = [[0 for c in range(self.columns)] for r in range(self.rows)];            # volumes[row][column]
            

    def toXML(self):
        xml = None;
#        total_volume = 0;
#        for each_row in self.volumes: 
#            for each_volume in each_row: 
#                total_volume = total_volume + each_volume;
#        if total_volume>0:          
        xml = etree.Element("consumable", attrib={'pattern':str(self.library_consumable.id), 
                                                  'x':str(self.gui_position_x),
                                                  'y':str(self.gui_position_y),
                                                  'id':str(self.id)});   
        label = etree.Element("label"); 
        label.text = etree.CDATA(str(self.label));
        required = etree.Element("required"); 
        required.text = 'true'; # options: {'true','false'} (it seems like this should always be set as true)                
        xml.append(label);
        xml.append(required);        
        comment_is_valid = ( (self.comment is not None) and (self.comment.strip() != '') );
        if comment_is_valid : 
            comment = etree.Element("comment"); 
            comment.text = etree.CDATA(str(self.comment));
            xml.append(comment);        
        is_single_well_container = self.rows*self.columns==1;
        if is_single_well_container :
            solution = self.stock_solutions[0][0];
            updated = False;                
            if solution is not None:
                id = solution.id;           
                volume = self.volumes[0][0];
                color = solution.color;                
                stock = etree.Element("stock_solution", attrib={  'color':str(color),
                                                                  'volume':str(volume),
                                                                  'stock_solution_id':str(id)}); 
                updated = True;
            if updated: 
                xml.append(stock);                   
        else: # is_multiple_well_container
            wells = etree.Element("wells"); 
            updated = False;
            for row in range(0,self.rows): 
                for column in range(0,self.columns): 
                    solution = self.stock_solutions[row][column];
                    if solution is not None:                            
                        id = solution.id;           
                        volume = self.volumes[row][column];
                        color = solution.color;
                        if abs(volume)>0:                    
                            well = etree.Element("well", attrib={'column':str(column+1),'row':str(row+1)});
                            stock = etree.Element("stock_solution", attrib={  'color':str(color),
                                                                              'volume':str(volume),
                                                                              'stock_solution_id':str(id)});                                                                     
                            well.append(stock);                 
                            wells.append(well);
                            updated = True;
            if updated: 
                xml.append(wells);       
        return xml 
    
    def __str__(self):
        xml = Consumable.toXML(self);
        if xml is not None:
            string = etree.tostring(xml, 
                           pretty_print=True, 
                           encoding="unicode")
        else:
            string = '';             
        return string
  
    def setSolution(self,**kwargs):
        params_required = (  'positions',       # list of position lists (ie: [[row,column],...]])                     
                             'volumes',         # list of volumes
                             'stock_solutions') # list of StockSolutions
        params = kwargs            
        if not set(params_required).issubset(params):
            raise Exception('not given all required parameters')
        else:
            positions = params['positions'];
            volumes   = params['volumes'];
            solutions = params['stock_solutions'];
            rows = self.rows;
            columns = self.columns;
            
            # check all equal length
            N = len(positions);
            if ( (len(positions)!=N) or (len(volumes)!=N) or (len(solutions)!=N) ) :
                raise Exception('parameters do not all have the same size')
            else:            
                for n in range(0,N):
                    position = positions[n];                    
                    if len(position)!=2:
                        raise Exception('incorrect size list provided as position')
                    else:     
                        row = position[0] - 1;
                        column = position[1] - 1;
                        if ( (row>rows) or (column>columns) ):
                            raise Exception('index exceeded size of array')                        
                        else:   
                            self.stock_solutions[row][column] = solutions[n];
                            self.volumes[row][column] = volumes[n];
        
    # example: 
    # lc = Andrew.LibraryConsumable(shortname='MTP384',type='microplate384',preparation='group',version=2,id='microplate384',name='384-well plate',display_name='MTP384',description='Generic microplate with 384 wells. This consumable describes typical square-shaped wells of capacity below 120 uL - with exclusion of 384-wells PCR microplates',category='Microplates',volume_dead=10000,volume_max=120000,size_columns=24,size_rows=16)    
    # s = Andrew.StockSolution(id='F618075D-BEE5-7EA2-7583-30243CDA1B49',name='DI Water',description='(PubChem CID:962)',color='13047173',concentration='1',concentration_unit='a.u.')
    # c = Andrew.Consumable(id='88AC8A29-CDE8-601C-CB75-3025CC1BFBA3',gui_position_x=650,gui_position_y=308,library_consumable=lc,label='dyed solution',comment='')
    # c.setSolution(positions=[[0,0]],volumes=[10],stock_solutions=[s]);
    # print(str(c))
        
    
    
# class for pipetting actions
class Action(object):
    
    def __init__(self,**kwargs):        
        params_required = [ 'type' ];   # type of action. actions supported: {'pipette', 'user', 'alert', 'incubate_start','incubate_end'}, not yet supported: {'serial dilution', 'cross reaction',  }              
        params_optional = [ 'level',    # level of incubation (between 0 and 2)
                            'position', # step position/number of this action (start counting actions at 1)
                            'message']; # message to describe this action
        params_optional_defaults = [ 0,  # level
                                     1,  # position
                                    '']; # message                          
        params = kwargs;                    
        
        if 'type' in params:
        
            # parameters required for each type of action
            params_user = ['expected_time']; # expected time of user intervention (in seconds) <expectedTime>
            params_alert = [];
            params_incubate = ['duration',         # duration of incubation (in seconds)
                               'position_offset']; # step position difference/offset between the specified start position and the desired end position (if incubation start position is step 1 and offset is 1 step, then the incubation stops at step 2) 
            params_pipette = [  'source',      # dictionary containing source "consumable" and "positions"
                                'destination', # dictionary containing destination "consumable" and "positions"
                                'volume',      # list of volumes
                                'params'];     # dictionary containing values for pipetting parameters
                              
                ### expected structure of pipette parameters      
                #            
                #    source      = {         'consumable': tubeDye, # <Andrew.Consumable>
                #                            'positions': [ [1,1] ]
                #                 };
                #    destination = {          'consumable': plateTarget, # <Andrew.Consumable> 
                #                            'positions': [ [1,2], [2,2], [3,2]]
                #                 };
                #
                #    volume = [25000];
                #    params = {       
                #                     'tip':{'no_blow_out': False, 'change_before':True, 'change_between':False, 'verify':False, 'touch_off':False,  'filter':False},
                #                     'precision':{'required':False}, 
                #                     'operation':{'speed':'normal', 'alicots':'-1', 'type':'forward'},
                #                     'viscosity':{'type':'normal'},
                #                     'cushion':{'top':False, 'bottom':False},
                #                     'source':{'pipette_position':{'height':0, 'type':'liquid', 'policy':'default'}, 'mixing':{'speed':'normal','number':0}},
                #                     'destination':{'pipette_position':{'height':0, 'type':'liquid', 'policy':'default'}, 'mixing':{'speed':'normal','number':0}}
                #             };
                #
                ###
                               
            # determine required parameters from the requested action
            action_type = params['type'];
            action_params = {
                                'pipette'  : params_pipette,
                                'user'     : params_user,
                                'alert'    : params_alert,
                                'incubate' : params_incubate,
                            };
            default_action_params = None;
            additional_params_required = action_params.get(action_type, default_action_params);       
            if additional_params_required is not None:
                params_required = params_required + additional_params_required;
                
        if not set(params_required).issubset(params):
            raise Exception('not given all required parameters')
        else:
            
            # optional parameter defaults
            if not set(params_optional).issubset(params):
                for n in range(0,len(params_optional)):
                    if params_optional[n] not in params:
                        params[params_optional[n]] = params_optional_defaults[n]; 
                        
            # update class parameters            
            self.__dict__.update(params)
            if self.type == 'incubate':
                self.expanded = False;
            
    
    def toXML(self):
        xml = None;
            
        if self.type == 'alert':            
            xml = etree.Element("action", attrib={'position':str(self.position+1),
                                                  'level':str(self.level),
                                                  'type':str(self.type) }); 
            message_is_valid = ( (self.message is not None) and (self.message.strip() != '') );
            if message_is_valid : 
                message = etree.Element("message"); 
                message.text = str(self.message);
                xml.append(message);  
                        
        if self.type == 'user':
            xml = etree.Element("action", attrib={'position':str(self.position+1),
                                                  'level':str(self.level),
                                                  'type':str(self.type).lower() }); 
            message_is_valid = ( (self.message is not None) and (self.message.strip() != '') );
            if message_is_valid : 
                message = etree.Element("message"); 
                message.text = str(self.message);
                xml.append(message);              
            expected_time = etree.Element("expectedTime"); 
            expected_time.text = str(self.expected_time); 
            xml.append(expected_time);
            
        if self.type == 'incubate': 
            if self.expanded:
                if self.position_offset == 0: # as in a start incubation action
                    xml = etree.Element("action", attrib={'position':str(self.position+1),
                                                          'level':str(self.level),
                                                          'type':str(self.type).lower(),
                                                          'duration':str(self.duration) }); 
                    message_is_valid = ( (self.message is not None) and (self.message.strip() != '') );
                    if message_is_valid : 
                        message = etree.Element("message"); 
                        message.text = str(self.message);
                        xml.append(message);  
                else: # as in an end incubation action
                    xml = etree.Element("action", attrib={'position':str(self.position+1+self.position_offset),
                                                          'level':str(self.level),
                                                          'type':str(self.type).lower()+'_end',
                                                          'related_incubate':str(self.position+1) }); 
            else:
                 raise Exception('incubation has not been expanded into its two sub-actions (start and end)')    
                            
            
        if self.type == 'pipette':            
            xml = etree.Element("action", attrib={'position':str(self.position+1),
                                                  'level':str(self.level),
                                                  'type':str(self.type).lower() }); 
            message_is_valid = ( (self.message is not None) and (self.message.strip() != '') );
            if message_is_valid : 
                message = etree.Element("message"); 
                message.text = str(self.message);
                xml.append(message);  
            
            #consumables
            consumables = etree.Element("consumables");
            sources = etree.Element("sources");
            sources_consumable = etree.Element("consumable", attrib={'target':str((self.source['consumable']).id)});
            positions = self.source['positions'];
            rows    = (self.source['consumable']).rows;
            columns = (self.source['consumable']).columns;
            if rows*columns>1:
                wells = etree.Element("wells");
                for position in positions:
                    if position[1]>columns or position[0]>rows:
                        raise Exception('well position out of bounds.')
                    else:
                        wells.append(etree.Element("well", attrib={'column':str(position[1]), 'row':str(position[0])}));
                sources_consumable.append(wells);
            sources.append(sources_consumable);
            consumables.append(sources);
            destinations = etree.Element("destinations");
            destinations_consumable = etree.Element("consumable", attrib={'target':str((self.destination['consumable']).id)});
            positions = self.destination['positions'];
            rows    = (self.destination['consumable']).rows;
            columns = (self.destination['consumable']).columns;
            if rows*columns>1:
                wells = etree.Element("wells");
                for position in positions:
                    if position[1]>columns or position[0]>rows:
                        raise Exception('well position out of bounds.')
                    else:
                        wells.append(etree.Element("well", attrib={'column':str(position[1]), 'row':str(position[0])}));
                destinations_consumable.append(wells);
            destinations.append(destinations_consumable);
            consumables.append(destinations);            
            xml.append(consumables);
            
            #volumes
            multivolume = len(self.volume)>1 and len(set(self.volume))>1;
            if multivolume:   
                if len(self.volume)==len(self.source['positions']) or len(self.volume)==len(self.destination['positions']):
                #if len(self.volume)==len((self.source['consumable']).rows) or len(self.volume)==len((self.destination['consumable']).rows):
                    volumes = etree.Element("volumes",attrib={'multi':str(multivolume).lower(),
                                                          'pasted':str(False).lower()});
                    for volume in self.volume:
                        vol = None;
                        vol = etree.Element("volume");
                        vol.text = str(volume); 
                        volumes.append(vol);
                    xml.append(volumes);
                else:
                    raise Exception('number of volumes and positions not equal')
            # not sure if needed as this was not in either example files 
            
            # params
            params = etree.Element("params");
            volume = etree.Element("volume");
            volume.text = str(max(self.volume));
            tip = etree.Element("tip", attrib={'no_blow_out':str((self.params['tip'])['no_blow_out']).lower(),
                                               'change_before':str((self.params['tip'])['change_before']).lower(), 
                                               'change_between':str((self.params['tip'])['change_between']).lower(),
                                               'verify':str((self.params['tip'])['verify']).lower(),
                                               'touch_off':str((self.params['tip'])['touch_off']).lower(),
                                               'filter':str((self.params['tip'])['filter']).lower(),
                                              });
            precision = etree.Element("precision", attrib={'required':str((self.params['precision'])['required']).lower()});
            operation = etree.Element("operation", attrib={'speed':str((self.params['operation'])['speed']).lower(),
                                                           'alicots':str((self.params['operation'])['alicots']), 
                                                           'type':str((self.params['operation'])['type']).lower()
                                                          });
            viscosity = etree.Element("viscosity", attrib={'type':str((self.params['viscosity'])['type']).lower()});
            cushion = etree.Element("cushion", attrib={'top':str((self.params['cushion'])['top']).lower(),
                                                       'bottom':str((self.params['cushion'])['bottom']).lower(), 
                                                      });
            source = etree.Element("source");    # 
            source_pipette_position = etree.Element("pipette_position", attrib={'height':str(((self.params['source'])['pipette_position'])['height']),
                                                                                'type':str(((self.params['source'])['pipette_position'])['type']).lower(), 
                                                                                'policy':str(((self.params['source'])['pipette_position'])['policy']).lower()
                                                                               });
            source_mixing = etree.Element("mixing", attrib={'speed':str(((self.params['source'])['mixing'])['speed']).lower(),
                                                            'number':str(((self.params['source'])['mixing'])['number'])
                                                          });
            source.append(source_pipette_position);
            source.append(source_mixing);            
            destination = etree.Element("destination");
            destination_pipette_position = etree.Element("pipette_position", attrib={'height':str(((self.params['destination'])['pipette_position'])['height']),
                                                                                'type':str(((self.params['destination'])['pipette_position'])['type']).lower(), 
                                                                                'policy':str(((self.params['destination'])['pipette_position'])['policy']).lower()
                                                                               });
            destination_mixing = etree.Element("mixing", attrib={'speed':str(((self.params['destination'])['mixing'])['speed']).lower(),
                                                            'number':str(((self.params['destination'])['mixing'])['number'])
                                                          });
            destination.append(destination_pipette_position);
            destination.append(destination_mixing);     
            params.append(volume);
            params.append(tip);
            params.append(precision);
            params.append(operation);
            params.append(viscosity);
            params.append(cushion);
            params.append(source);            
            params.append(destination);            
            xml.append(params);            
            
        return xml    
    
    
    def __str__(self):
        return etree.tostring(Action.toXML(self), 
                              pretty_print=True, 
                              encoding="unicode")
      
    
    def reposition(list_of_actions): # sort actions according to how the actions are listed (taking account of the need to expand incubation actions into two-steps)
        Ninc = 0;
        original_list_of_actions = deepcopy(list_of_actions);
        for action in original_list_of_actions:
            if action.type == 'incubate':
                Ninc = Ninc + 1;
        N = len(list_of_actions) + Ninc;
        available_steps = [n for n in range(0,N)];
        if Ninc>0:
            list_of_actions.append([None]*Ninc);
        for action in original_list_of_actions:
            action.position = available_steps[0];
            list_of_actions[action.position] = action;
            available_steps.pop(0);
            if action.type == 'incubate':  # flatten/expand multi-step actions (namely incubate) into two seperate actions that can be read by Andrew
                pop_position = action.position_offset-1;
                if pop_position <= (len(available_steps) - 1):
                    available_steps.pop(pop_position); 
                else: # too large of a position offset for action list size, so change the offset
                    action.position_offset = len(available_steps);
                    available_steps.pop();
                list_of_actions[action.position + action.position_offset] = deepcopy(action);
                (list_of_actions[action.position + action.position_offset]).expanded = True; 
                (list_of_actions[action.position]).expanded = True;                                               
                (list_of_actions[action.position]).position_offset = 0;
        return list_of_actions
    
        
    # example: 
    # a = 
    # print(str(a))    
    
    
## class for adjustable pipette (not used since currently we are reading this from a template file 'pipette_set.xml')
#    
#class Pipette:
#    
#    def __init__(self,**kwargs):
#        params_required = (  'type',
#                             'model',
#                             'brand',
#                             'visual_wrench',
#                             'visual_ratio',
#                             'visual_pastille',
#                             'volume_elution_max',
#                             'volume_elution_min',
#                             'volume_max',
#                             'volume_min',
#                             'tips_cork_ratio',
#                             'tips_cork_color',
#                             'tips_name',
#                             'tips_filter_cork_ratio',
#                             'tips_filter_cork_color',
#                             'tips_filter_name',
#                             'waste_volume')               
#        params = kwargs            
#        if not set(params_required).issubset(params):
#            raise Exception('not given all required parameters')
#        else:
#            self.__dict__.update(kwargs)
#    
#    def toXML(self):
#        xml = etree.Element("pipette");   
#        # incomplete
#        return xml    
#    
#    def __str__(self):
#        return etree.tostring(Pipette.toXML(self), 
#                              pretty_print=True, 
#                              encoding="unicode")
#
#    #        <type><![CDATA[P2]]></type>
#    #        <model><![CDATA[PIPETMAN Classic?]]></model>
#    #        <brand><![CDATA[Gilson]]></brand>
#    #        <visual wrench="15921906" ratio="0.43" pastille="15032858"/>
#    #        <volumes elution_max="2000" min="200" max="2000" elution_min="200"/>
#    #        <tips cork_ratio="0.65" cork_color="14037811" name="D10"/>
#    #        <tips_filter cork_ratio="0.65" cork_color="14037811" name="DF10"/>
#    #        <waste_volume>2000</waste_volume>


# helper methods
    
def getUniqueID():# provide a random new and unique ID
    lengthID = 36;
    date = (datetime.now()).strftime("%Y%m%d%H%M%S%f");
    lengthDate = len(date);
    lengthRand = lengthID - lengthDate;
    rand = str(round(random.uniform(0, 1)*(10**lengthRand)));
    ID = date + rand;
    ID = ID[0:lengthID];
    # print(ID+'('+str(len(ID))+')')
    return ID 

def getNewColor(): # provide a random new color
    color_max_value = int('0xFFFFFF', 16); # white
    color = round(random.uniform(0, 1)*color_max_value);    
    return color

#def volumeRounder(exact_volumes) : # function to round volumes to values that can be realized by the pipette set Andrew is equipped with
#    
#    # load available pipettes
#    parser = etree.XMLParser(strip_cdata=False);
#    classfilepath = os.path.dirname(os.path.realpath(__file__));
#    doc = etree.parse(classfilepath + "/resource/pipette_set.xml",parser);
#    root = doc.getroot();
#    
#    # convert pipette data to volume limits
#    pips = root.xpath('//pipette');
#    #Npips = len(pips)
#    types = [];
#    VholdMax = [];
#    VholdMin = [];
#    VtransferMax = [];
#    VtransferMin = [];
#    for pipette in pips:    
#        types = types + pipette.xpath('type/text()'); 
#        v = pipette.xpath('volumes');
#        VholdMax = Vmax + [int(v[0].get('max'))];
#        VholdMin = Vmin + [int(v[0].get('min'))];
#        #print(etree.tostring(pipette, pretty_print=True))
#        #print('\n')
#
#    # find pipette with closest value and round
#    volume_error_percent = 1/100; # spec sheet error expressed in percent of max pipette volume
#    VholdDelta = VholdMax
#    rounded_volumes = exact_volumes.copy;
#    for volume in exact_volumes:
#        if volume > max(VholdMax) or volume < min(VholdMax):
#            raise Exception('volume outside of range of all pipettes)
#        elif volume > 
#        volume = round(volume);        
#    return rounded_volumes

